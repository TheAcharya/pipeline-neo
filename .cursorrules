# Pipeline Neo - Cursor Rules

Pipeline Neo is a modern, fully modular Swift 6 framework for Final Cut Pro FCPXML processing with SwiftTimecode integration. The codebase underwent a complete rewrite and refactor: it is 100% protocol-oriented, with all major operations defined as protocols and implemented via dependency injection for maximum flexibility, testability, and future-proofing.

Keep this file in sync with AGENT.md. Both should describe the same overview, architecture, test structure, and conventions. When you update one, update the other.

---

## Table of Contents

- [Project Overview](#project-overview)
- [Codebase Rewrite and Refactor](#codebase-rewrite-and-refactor)
- [Modularity and Safety](#modularity-and-safety)
- [Code Style and Formatting](#code-style-and-formatting)
- [Architecture Guidelines](#architecture-guidelines)
- [Dependencies](#dependencies)
- [File Organisation](#file-organisation)
- [Test Structure](#test-structure)
- [Development Patterns](#development-patterns)
- [Testing Requirements](#testing-requirements)
- [Performance Considerations](#performance-considerations)
- [Documentation Standards](#documentation-standards)
- [Git Workflow](#git-workflow)
- [Quality Assurance](#quality-assurance)
- [Project-Specific Rules](#project-specific-rules)
- [External References](#external-references)
- [Common Tasks](#common-tasks)
- [Code Generation Guidelines](#code-generation-guidelines)
- [Documentation Sync](#documentation-sync)
- [Maintenance](#maintenance)

---

## Project Overview

Pipeline Neo targets macOS 12+, Xcode 16+, and Swift 6.0 with full concurrency support. It provides FCPXML parsing, creation, and manipulation with timecode operations via SwiftTimecode. All core behaviour is behind protocols with both synchronous and async/await APIs; default implementations exist but any component can be swapped or extended via dependency injection.

Current status: all 174 tests passing; FCPXML versions 1.5–1.14 supported (DTDs included, full parsing, typed element-type coverage for all DTD elements via FCPXMLElementType); Final Cut Pro frame rates (23.976, 24, 25, 29.97, 30, 50, 59.94, 60); thread-safe and concurrency-compliant with comprehensive async/await support; no known security vulnerabilities. Comprehensive code audit completed.

---

## Codebase Rewrite and Refactor

The project was fully rewritten and refactored to achieve:

- A protocol-oriented design: parsing, timecode conversion, XML manipulation, and error handling are defined as protocols (e.g. FCPXMLParsing, TimecodeConversion, XMLDocumentOperations, ErrorHandling) with sync and async/await methods.
- A single injection point for extension APIs that cannot take parameters: FCPXMLUtility.defaultForExtensions (concurrency-safe). No hidden concrete types in extensions; for custom pipelines use the modular API with the using: parameter.
- Consistent source layout: Analysis (EditPoint, CutDetectionResult), Classes, Delegates, Errors, Extensions (including +Modular), Implementations, Protocols, Services, Utilities, and FCPXML DTDs.
- A structured test suite: shared resources, file tests per sample, logic/parsing tests, timeline/export/validation tests, API and edge-case tests, and performance tests, all documented in Tests/README.md.

Foundation XML types (XMLDocument, XMLElement) and SwiftTimecode types are not Sendable. The codebase avoids Task-based concurrency for these types but provides async/await APIs that are concurrency-safe for Swift 6. If these dependencies become Sendable in the future, further parallelisation can be introduced.

---

## Modularity and Safety

- All core operations are defined as protocols with both sync and async/await APIs. Default implementations are provided; any component can be swapped or extended via dependency injection. ErrorHandling protocol is sync-only (pure formatting, no I/O).
- Extension APIs that cannot take parameters use a single shared instance, FCPXMLUtility.defaultForExtensions (concurrency-safe). No hidden concrete types in extensions; for custom pipelines use the modular API with using: parameter. CMTime.fcpxmlString delegates to FCPXMLUtility.defaultForExtensions.fcpxmlTime(fromCMTime:) for consistent formatting.
- FCPXMLParser delegates URL loading to FCPXMLFileLoader for unified file/bundle handling and consistent FCPXML parse options. There is one code path for loading FCPXML from URLs.
- ModularUtilities.validateDocument delegates to FCPXMLValidator for semantic validation (root element, resources, ref resolution). convertTimecodes uses the injected FCPXMLTimeStringConversion protocol rather than inline parsing.
- FCPXMLUtility routes debugLog through its injected PipelineLogger; extension types use #if canImport(Logging) as a fallback for contexts without DI.
- FCPXMLVersion (DTD validation, 1.5-1.14) and FinalCutPro.FCPXML.Version (parsing, 1.0-1.14) are bridged via .fcpxmlVersion, .dtdVersion, and init(from:) converters.
- Module-scoped errors: FCPXMLError for parsing, FCPXMLLoadError for file I/O (notAFile, readFailed), FCPXMLExportError/FCPXMLBundleExportError for export, FinalCutPro.FCPXML.ParseError (with LocalizedError). Parse failures from all layers surface as FCPXMLError.parsingFailed. FCPXMLElementError uses String element names for Sendable compliance. FCPXMLDocumentError uses camelCase cases (dtdResourceNotFound, dtdResourceUnreadable).
- All code is Sendable where appropriate; `@unchecked Sendable` removed from delegates (internal-only, used synchronously). The project builds and tests with Swift 6 strict concurrency (-strict-concurrency=complete). CI runs a job that enforces this.
- No known vulnerabilities in dependencies (including SwiftTimecode 3.0.0) as of July 2025. No unsafe pointers, dynamic code execution, or C APIs; concurrency is structured and type-safe.
- Async/await support is comprehensive across all protocols, implementations, services, and utilities.

---

## Code Style and Formatting

Swift conventions: use Swift 6.0 syntax and features; follow Swift API Design Guidelines; camelCase for variables and functions; PascalCase for types and protocols; descriptive, clear names for all identifiers.

Documentation: include comprehensive /// doc comments for all public APIs; provide usage examples; document all parameters, return values, and exceptions.

### File Header

All new Swift files must use this exact header format:

```
//
//  FileName.swift
//  Pipeline Neo • https://github.com/TheAcharya/pipeline-neo
//  © 2026 • Licensed under MIT License


//
//	Brief description of the file's purpose.
//
```

Rules:
- Replace `FileName.swift` with the actual file name.
- Replace the purpose line with a concise description of what the file contains.
- The purpose block uses a tab character after `//`, not spaces.
- Two blank lines separate the header block from the purpose block.
- Do not add `//  PipelineNeo`, `Created by`, or `Copyright ©` lines.

---

## Architecture Guidelines

Concurrency: use async/await for asynchronous operations (all major operations have async/await APIs). Implement proper Sendable compliance; use @unchecked Sendable for classes that cannot be made final. Avoid capturing non-Sendable types in concurrent contexts. Use structured concurrency (Task, TaskGroup) only where types are Sendable. Foundation XML types and SwiftTimecode types are not Sendable; async/await APIs are provided, but Task-based concurrency is avoided for these types.

Error handling: use Swift Result for operations that can fail; provide meaningful error messages; implement proper error propagation; use do-catch for sync; create specific error types (FCPXMLError) for failure scenarios.

Type safety: use strongly typed enums for FCPXML elements (FCPXMLElementType); implement type-safe timecode operations; use optionals appropriately; avoid force unwrapping unless necessary.

---

## Dependencies

Primary: SwiftTimecode 3.0.0+ for timecode operations; SwiftExtensions 2.0.0+ (orchetect/swift-extensions) for String, Collection, Optional, XML helpers where useful; Foundation for XML and data; CoreMedia for CMTime.

Version requirements: Swift 6.0+, Xcode 16.0+, macOS 12.0+.

SwiftTimecode usage: use Timecode(.realTime(seconds: seconds), at: frameRate) instead of the old realTime: at: initialiser. Use frame rate cases .fps23_976, .fps24, .fps25, .fps29_97, .fps30, .fps50, .fps59_94, .fps60 instead of ._24, ._25, etc.

---

## File Organisation

Source structure: layout is Classes (FinalCutPro, FCPXML core types, FCPXMLElementType, FCPXMLUtility, FCPXMLVersion, FCPXML Root, FCPXML Root Version), Delegates, Errors (FCPXMLError, FCPXML ParseError), Extensions (including +Modular: CMTime+Modular, XMLDocument+Modular, XMLElement+Modular), Implementations, Protocols, Services, Utilities (ModularUtilities, FCPXML Time Utilities, SequencePlusAnySequence, XMLElementAncestorWalking, XMLElementSequenceAttributes), Annotations (creation-oriented value types; for parsing models see Model/), Export (FCPXMLExporter, FCPXMLBundleExporter, FCPXMLExportAsset), Timeline (Timeline, TimelineClip), Validation (FCPXMLValidator, FCPXMLDTDValidator, ValidationResult, ValidationError/Warning), FileIO (FCPXMLFileLoader), Logging (PipelineLogger, NoOpPipelineLogger, PrintPipelineLogger), Format (ColorSpace), Model (element models with subfolders: Attributes, Clips, CommonElements, ElementTypes, Occlusion, Protocols, Resources, Roles, Structure), Parsing (XML parsing extensions), Extraction (extraction logic with Context/ and Presets/ subfolders), FCPXML DTDs. Group related functionality in extensions; keep files focused on single responsibilities; use clear file naming conventions; organise imports logically; maintain the existing directory structure.

---

## Test Structure

Tests live under Tests/. Full description is in Tests/README.md. Summary:

- Tests/README.md: test categories, how to run (Swift PM, Xcode, Linux), sample files, frame rates, FCPXML versions. Keep it current when adding or changing tests.

- Tests/FCPXML Samples/FCPXML/: sample .fcpxml files. File tests and logic tests load these via shared utilities; tests that require a missing sample use XCTSkip.

- Tests/PipelineNeoTests/: TestResources.swift (packageRoot, fcpxmlSamplesDirectory, urlForFCPXMLSample, FCPXMLSampleName); FCPXMLTestUtilities.swift (loadFCPXMLSampleData, loadFCPXMLSample, fcpxmlFrameRateSampleNames, allFCPXMLSampleNames; XCTSkip when sample missing). PipelineNeoTests.swift: main test class with injected dependencies; MARK sections group tests. FileTests/: one test class per sample or category (e.g. FCPXMLFileTest_24, FCPXMLFileTest_Structure, FCPXMLFileTest_AllSamples, FCPXMLFileTest_FrameRates). LogicAndParsing/: FCPXMLRootVersionTests, FCPXMLStructureTests. TimelineExportValidationTests: timeline, exporters, validators, file loader. APIAndEdgeCaseTests: async load API, PipelineLogger injection, edge cases. FCPXMLPerformanceTests: parameterised and basic performance tests.

Use descriptive test method names; group related tests logically; include setup and teardown; use meaningful assertions. Current total: 174 comprehensive tests covering all functionality including async/await.

---

## Development Patterns

Async operations: standard async pattern for time conversions (implementation returns Timecode or nil). Task-based concurrent operations only when element types are Sendable.

Error handling: Result-based for sync APIs; async APIs throw and propagate FCPXMLError (e.g. parsingFailed(error)). Use do-catch and meaningful error types.

SwiftTimecode integration: use SwiftTimecode for all timecode operations; support all FCPXML frame rates (Final Cut Pro compatible); implement proper frame rate conversions; use the new Timecode(.realTime(seconds:), at:) API and updated frame rate enum cases (.fps24, .fps25, etc.).

---

## Testing Requirements

Test coverage: unit tests for all public APIs; integration tests for complex workflows; performance tests for time-critical operations; concurrency tests for async operations; test all supported frame rates (Final Cut Pro compatible). Current: 174 comprehensive tests covering all functionality including async/await.

Test data: use realistic FCPXML samples; include edge cases and error conditions; test all supported frame rates; validate against actual Final Cut Pro output where applicable.

Test organisation: descriptive test method names; group related tests logically; proper setup and teardown; meaningful assertions.

Supported frame rates for testing: 23.976, 24, 25, 29.97, 30, 50, 59.94, 60 fps only.

---

## Performance Considerations

Memory: use value types where appropriate; implement proper resource cleanup; avoid retain cycles in closures; use weak references for delegates.

Concurrency: use appropriate concurrency levels; implement proper task cancellation; avoid blocking the main thread; use structured concurrency for complex operations.

XML processing: stream large documents when possible; use efficient XML parsing techniques; implement proper memory management for large files; cache frequently accessed data.

---

## Documentation Standards

Code documentation: comprehensive header comments for all public APIs; parameter and return value documentation; usage examples in comments; exception documentation.

README updates: update README.md when adding new features; include usage examples; document breaking changes; keep installation instructions current.

Inline comments: explain complex algorithms; document business logic; clarify non-obvious code; reference external specifications.

---

## Git Workflow

Commit messages: use clear, descriptive commit messages; reference issue numbers when applicable; separate subject from body with blank line; use imperative mood.

Branch strategy: main (production-ready), dev, feature/*, bugfix/*.

---

## Quality Assurance

Code review checklist: all tests passing; documentation updated; error handling implemented; performance considerations addressed; concurrency requirements met.

Build requirements: Swift build successful; all tests passing; no warnings or errors; proper dependency resolution.

---

## Project-Specific Rules

FCPXML handling: support FCPXML versions 1.5 through 1.14 (DTDs included; full parsing; typed element-type coverage via FCPXMLElementType for all DTD elements); validate against DTD schemas; handle all supported frame rates (Final Cut Pro compatible); implement proper XML formatting. Media extraction: extract media references (asset media-rep src, locator url) and copy referenced file URLs to a destination directory (MediaExtraction protocol, MediaExtractor).

Timecode operations: use SwiftTimecode for all timecode operations; support all FCPXML frame rates (Final Cut Pro compatible); implement proper frame rate conversions; handle drop frame and non-drop frame timecode.

Platform support: target macOS 12.0+; use Xcode 16.0+ features; implement Swift 6.0 concurrency; follow Apple platform guidelines.

---

## External References

Documentation: Final Cut Pro XML (fcp.cafe/developers/fcpxml/), SwiftTimecode (github.com/orchetect/swift-timecode), Swift Concurrency (docs.swift.org). Standards: Swift API Design Guidelines, Apple Human Interface Guidelines, Final Cut Pro XML specifications, SwiftTimecode API conventions.

---

## Common Tasks

Adding new features: create feature branch; implement functionality with tests; update documentation; ensure all tests pass; create pull request.

Bug fixes: create bugfix branch; implement fix with regression tests; update documentation if needed; ensure all tests pass; create pull request.

Performance improvements: measure current performance; implement improvements; add performance tests; measure improvement; document changes.

---

## Code Generation Guidelines

When generating code: follow existing patterns and conventions; include comprehensive tests; add proper documentation; ensure concurrency compliance; validate against project requirements.

Code review process: review for Swift 6.0 compliance; check concurrency implementation; validate error handling; ensure test coverage; verify documentation quality.

---

## Documentation Sync

Keep this file in sync with AGENT.md. Both must reflect: project overview and codebase rewrite/refactor; architecture and single injection point (FCPXMLUtility.defaultForExtensions); source layout (Analysis, Classes, Delegates, Errors, Extensions including +Modular, Implementations, Media, Protocols, Services, Utilities, Annotations, Export, Timeline, Validation, FileIO, Logging, Format, Model, Parsing, Extraction, FCPXML DTDs); test structure (Tests/ layout, TestResources, FCPXMLTestUtilities, FileTests/, LogicAndParsing/, CutDetectionTests, VersionConversionTests, MediaExtractionTests, PipelineNeoTests.swift, TimelineExportValidationTests, APIAndEdgeCaseTests, FCPXMLPerformanceTests; 174 tests); FCPXML 1.5–1.14 and FCPXMLElementType; Final Cut Pro frame rates; Swift 6 concurrency (Sendable, async/await, CI strict-concurrency job). When updating either file, update both and keep terminology and examples consistent.

---

## Maintenance

Regular tasks: update dependencies as needed; review and update documentation; monitor test coverage; address warnings or deprecations; keep build configuration current.

Long-term: plan for future Swift versions; consider new FCPXML versions; monitor SwiftTimecode updates; plan for platform changes; maintain backward compatibility where possible.
